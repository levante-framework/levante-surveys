#!/usr/bin/env node

/**
 * Download Survey CSV Files from Crowdin (levante_translations repo)
 *
 * This script downloads the latest survey translation CSV files from the
 * levante_translations repository's l10n_pending branch. These files are
 * generated by Crowdin and contain the most current translation data.
 *
 * Repository: https://github.com/levante-framework/levante_translations
 * Branch: l10n_pending
 *
 * Usage:
 *   node scripts/download-crowdin-surveys.js [options]
 *
 * Options:
 *   --force         Overwrite existing CSV files
 *   --survey=NAME   Download specific survey only
 *   --backup        Backup existing CSV files before downloading
 *
 * Examples:
 *   node scripts/download-crowdin-surveys.js
 *   node scripts/download-crowdin-surveys.js --force
 *   node scripts/download-crowdin-surveys.js --survey=child_survey --backup
 */

import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'
import https from 'https'

// Get current directory
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const projectRoot = path.resolve(__dirname, '..')

// Crowdin CSV source file and target mappings
const CROWDIN_SOURCE_URL = 'https://raw.githubusercontent.com/levante-framework/levante_translations/l10n_pending/surveys.csv'

const TARGET_CSV_FILES = [
  'child_survey_crowdin_translations.csv',
  'parent_survey_family_crowdin_translations.csv',
  'parent_survey_child_crowdin_translations.csv',
  'teacher_survey_general_crowdin_translations.csv',
  'teacher_survey_classroom_crowdin_translations.csv'
]

// Element name patterns are now defined in splitCombinedCSV function

/**
 * Download a file from URL to local path
 */
function downloadFile(url, localPath) {
  return new Promise((resolve, reject) => {
    const file = fs.createWriteStream(localPath)

    https.get(url, response => {
      if (response.statusCode !== 200) {
        reject(new Error(`HTTP ${response.statusCode}: ${response.statusMessage} for ${url}`))
        return
      }

      response.pipe(file)

      file.on('finish', () => {
        file.close()
        resolve()
      })

      file.on('error', err => {
        fs.unlink(localPath, () => {}) // Delete incomplete file
        reject(err)
      })
    }).on('error', err => {
      reject(err)
    })
  })
}

/**
 * Get file size in a human-readable format
 */
function getFileSize(filePath) {
  try {
    const stats = fs.statSync(filePath)
    const bytes = stats.size

    if (bytes < 1024) return `${bytes} B`
    if (bytes < 1024 * 1024) return `${Math.round(bytes / 1024)} KB`
    return `${Math.round(bytes / (1024 * 1024))} MB`
  } catch {
    return 'unknown'
  }
}

/**
 * Backup existing file
 */
function backupFile(filePath) {
  if (!fs.existsSync(filePath)) return null

  const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
  const backupPath = filePath.replace('.csv', `_backup_${timestamp}.csv`)

  fs.copyFileSync(filePath, backupPath)
  return backupPath
}

/**
 * Validate CSV file content
 */
function validateCSV(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8')
    const lines = content.trim().split('\n')

    if (lines.length < 2) {
      return { valid: false, error: 'File appears to be empty or has no data rows' }
    }

    const header = lines[0]
    // Check for either the old format (item_id, element_name) or new format (identifier, labels)
    const hasOldFormat = header.includes('item_id') && header.includes('element_name')
    const hasNewFormat = header.includes('identifier') && header.includes('labels')

    if (!hasOldFormat && !hasNewFormat) {
      return { valid: false, error: 'Missing required columns: expected either (item_id, element_name) or (identifier, labels)' }
    }

    if (!header.includes('en')) {
      return { valid: false, error: 'Missing required column: en' }
    }

    // Count language columns
    const languageColumns = header.split(',').filter(col =>
      col.match(/^[a-z]{2}(-[A-Z]{2})?$/) || col === 'en'
    ).length

    return {
      valid: true,
      rows: lines.length - 1,
      languages: languageColumns,
      size: getFileSize(filePath)
    }
  } catch (error) {
    return { valid: false, error: error.message }
  }
}

/**
 * Parse the combined CSV and split by survey prefixes
 */
function splitCombinedCSV(csvContent) {
  const lines = csvContent.trim().split('\n')
  if (lines.length < 2) return {}

  const header = lines[0]
  const surveyFiles = {}

  // Initialize each survey file with header
  for (const filename of TARGET_CSV_FILES) {
    surveyFiles[filename] = [header]
  }

  // Survey name to filename mapping
  const SURVEY_NAME_MAPPING = {
    'child_survey': 'child_survey_crowdin_translations.csv',
    'parent_survey_family': 'parent_survey_family_crowdin_translations.csv',
    'parent_survey_child': 'parent_survey_child_crowdin_translations.csv',
    'teacher_survey_general': 'teacher_survey_general_crowdin_translations.csv',
    'teacher_survey_classroom': 'teacher_survey_classroom_crowdin_translations.csv'
  }

  // Find the labels column index
  const headerColumns = parseCSVLine(header)
  const labelsIndex = headerColumns.indexOf('labels')
  
  if (labelsIndex === -1) {
    console.log('   ‚ö†Ô∏è  No labels column found, falling back to identifier patterns')
    return splitByIdentifierPatterns(lines, header, surveyFiles)
  }

  console.log(`   üìã Using labels column (index ${labelsIndex}) for survey grouping`)

  // Process each data row
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i].trim()
    if (!line) continue

    const columns = parseCSVLine(line)
    if (columns.length <= labelsIndex) continue

    const surveyName = columns[labelsIndex]
    const filename = SURVEY_NAME_MAPPING[surveyName]

    if (filename && surveyFiles[filename]) {
      surveyFiles[filename].push(line)
    } else {
      // Try fallback patterns if survey name doesn't match
      const identifier = columns[0] || ''
      let matched = false
      
      // Simple fallback based on common patterns
      if (identifier.toLowerCase().includes('child')) {
        surveyFiles['child_survey_crowdin_translations.csv'].push(line)
        matched = true
      } else if (identifier.toLowerCase().includes('family')) {
        surveyFiles['parent_survey_family_crowdin_translations.csv'].push(line)
        matched = true
      } else if (identifier.toLowerCase().includes('parent')) {
        surveyFiles['parent_survey_child_crowdin_translations.csv'].push(line)
        matched = true
      } else if (identifier.toLowerCase().includes('teacher') && identifier.toLowerCase().includes('general')) {
        surveyFiles['teacher_survey_general_crowdin_translations.csv'].push(line)
        matched = true
      } else if (identifier.toLowerCase().includes('teacher')) {
        surveyFiles['teacher_survey_classroom_crowdin_translations.csv'].push(line)
        matched = true
      }

      if (!matched) {
        console.log(`   ‚ö†Ô∏è  Unmatched row - Survey: "${surveyName}", Identifier: "${identifier}"`)
      }
    }
  }

  return surveyFiles
}

// Helper function to parse CSV line respecting quotes
function parseCSVLine(line) {
  const result = []
  let current = ''
  let inQuotes = false
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i]
    
    if (char === '"') {
      inQuotes = !inQuotes
    } else if (char === ',' && !inQuotes) {
      result.push(current.trim())
      current = ''
    } else {
      current += char
    }
  }
  
  result.push(current.trim())
  return result
}

/**
 * Download survey CSV files from Crowdin
 */
async function downloadCrowdinSurveys(options = {}) {
  const { force = false, survey = null, backup = false } = options
  const surveysDir = path.join(projectRoot, 'surveys')

  console.log('üì• Downloading Survey CSV Files from Crowdin')
  console.log('='.repeat(50))
  console.log(`üìÅ Target directory: ${surveysDir}`)
  console.log(`üîÑ Force overwrite: ${force}`)
  console.log(`üì¶ Backup existing: ${backup}`)
  console.log('')

  // Ensure surveys directory exists
  if (!fs.existsSync(surveysDir)) {
    fs.mkdirSync(surveysDir, { recursive: true })
  }

  try {
    // Download the combined CSV file
    console.log('üìã Downloading combined surveys file...')
    console.log(`   ‚¨áÔ∏è  Source: ${CROWDIN_SOURCE_URL}`)

    const tempPath = path.join(surveysDir, 'temp_surveys.csv')
    await downloadFile(CROWDIN_SOURCE_URL, tempPath)

    // Read and split the CSV content
    console.log('   üîÄ Splitting into individual survey files...')
    const csvContent = fs.readFileSync(tempPath, 'utf8')
    const surveyFiles = splitCombinedCSV(csvContent)

    // Clean up temp file
    fs.unlinkSync(tempPath)

    const results = []

    // Filter files if specific survey requested
    const filesToProcess = survey
      ? TARGET_CSV_FILES.filter(filename => filename.includes(survey))
      : TARGET_CSV_FILES

    if (filesToProcess.length === 0) {
      console.log(`‚ùå No survey files found matching: ${survey}`)
      return { success: false, results: [] }
    }

    // Write individual survey CSV files
    for (const filename of filesToProcess) {
      const localPath = path.join(surveysDir, filename)
      const exists = fs.existsSync(localPath)

      console.log(`üìã Processing: ${filename}`)

      // Handle existing files
      if (exists && !force) {
        console.log(`   ‚ö†Ô∏è  File exists, skipping (use --force to overwrite)`)
        results.push({
          file: filename,
          status: 'skipped',
          reason: 'exists'
        })
        continue
      }

      // Backup if requested
      let backupPath = null
      if (exists && backup) {
        backupPath = backupFile(localPath)
        console.log(`   üì¶ Backed up to: ${path.basename(backupPath)}`)
      }

      try {
        // Write the split CSV content
        const csvLines = surveyFiles[filename] || [surveyFiles[Object.keys(surveyFiles)[0]][0]] // At least header
        const csvContent = csvLines.join('\n')

        fs.writeFileSync(localPath, csvContent, 'utf8')

        // Validate written file
        const validation = validateCSV(localPath)

        if (!validation.valid) {
          console.log(`   ‚ùå Invalid CSV: ${validation.error}`)
          results.push({
            file: filename,
            status: 'error',
            error: validation.error
          })
          continue
        }

        console.log(`   ‚úÖ Created: ${validation.rows} rows, ${validation.languages} languages, ${validation.size}`)
        results.push({
          file: filename,
          status: 'success',
          rows: validation.rows,
          languages: validation.languages,
          size: validation.size,
          backupPath
        })

      } catch (error) {
        console.log(`   ‚ùå Failed to create ${filename}: ${error.message}`)
        results.push({
          file: filename,
          status: 'error',
          error: error.message
        })
      }
    }

    // Summary
    const successful = results.filter(r => r.status === 'success').length
    const failed = results.filter(r => r.status === 'error').length
    const skipped = results.filter(r => r.status === 'skipped').length

    console.log('\nüìä Download Summary')
    console.log('='.repeat(30))
    console.log(`‚úÖ Successful: ${successful}`)
    console.log(`‚ùå Failed: ${failed}`)
    console.log(`‚è≠Ô∏è  Skipped: ${skipped}`)

    if (successful > 0) {
      console.log('\nüìã Created Files:')
      results.filter(r => r.status === 'success').forEach(result => {
        console.log(`   ‚Ä¢ ${result.file}: ${result.rows} translations, ${result.languages} languages`)
      })
    }

    if (failed > 0) {
      console.log('\n‚ùå Failed Files:')
      results.filter(r => r.status === 'error').forEach(result => {
        console.log(`   ‚Ä¢ ${result.file}: ${result.error}`)
      })
    }

    const success = failed === 0 && successful > 0
    console.log(`\n${success ? 'üéâ' : '‚ö†Ô∏è'} Download ${success ? 'completed successfully' : 'completed with issues'}!`)

    return { success, results }

  } catch (error) {
    console.error(`‚ùå Failed to download combined CSV: ${error.message}`)
    return {
      success: false,
      results: [{
        file: 'combined_download',
        status: 'error',
        error: error.message
      }]
    }
  }
}

/**
 * Main function
 */
async function main() {
  const args = process.argv.slice(2)

  const options = {
    force: args.includes('--force'),
    backup: args.includes('--backup'),
    survey: args.find(arg => arg.startsWith('--survey='))?.split('=')[1]
  }

  if (args.includes('--help') || args.includes('-h')) {
    console.log(`
üì• Crowdin Survey CSV Downloader

Downloads the latest survey translation CSV files from the levante_translations
repository's l10n_pending branch. These files are generated by Crowdin.

Usage:
  node scripts/download-crowdin-surveys.js [options]

Options:
  --force           Overwrite existing CSV files
  --survey=NAME     Download specific survey only (e.g., child_survey)
  --backup          Backup existing CSV files before downloading
  --help, -h        Show this help message

Examples:
  node scripts/download-crowdin-surveys.js
  node scripts/download-crowdin-surveys.js --force
  node scripts/download-crowdin-surveys.js --survey=child_survey --backup

Repository: https://github.com/levante-framework/levante_translations
Branch: l10n_pending
`)
    return
  }

  try {
    const result = await downloadCrowdinSurveys(options)
    process.exit(result.success ? 0 : 1)
  } catch (error) {
    console.error('\nüí• Unexpected error:', error.message)
    process.exit(1)
  }
}

// Run the script
if (import.meta.url === `file://${process.argv[1]}`) {
  main()
}

export { downloadCrowdinSurveys }
